<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>lecture01.html</title>
</head>
<body>
  <!-- 프로토타입 공부용용 -->
  <p id="demo"></p>
  <!--  -->


  <script>
//////////////////////////////////////////////////////////////////////////////////////////
/* 프토토타입 공부 */
//자스의 모든 객체는 프로토타입객체를 가지고 있다.
//프로토타입객체,체인,상속이 있다.
//프로토타입객체 : 해당객체가 사용할 수 있는 메소드와 속성을 정의한다.
//프로토타입체인 : 객체는 체인을 따라 상속받은 메서드와 속성을 찾는다.
//프로토타입상속 : 객체는 다른 객체의 프로토타입을 상속받아 메서드와 속성을 공유할 수 있다.

 //생성자 함수 정의
 /*
function Saram(name,age){
      this.name = name;
      this.age = age;
  }
Saram.prototype.greet = function(){
  console.log('hello, proto')
};

    Person.prototype.nationality = "English";

    const myFather = new Saram("John","Doe",50,"blue");
    const myMother = new Saram("Sally","Rally",48,"green");

    document.getElementById("demo").innerHTML = 
    "The nationality of  my father is "+ myFather.nationality;
*/
//////////////////////////////////////////////////////////////////////////////////////////


const button = document.querySelector('button');
    /*
    button.addEventListener('click',function(){
      console.log(`this는 ${this}`);
      console.log(this === window);
      console.log(this === button);
    });
    */
   /*
    button.onclick = function () {
      console.log(`this는 ${this}`);
      console.log(this === window);
      console.log(this === button);
    };
    */


    function print() {
      console.log(this);
    }
    print();

const person1 = {username:"kim"};
const person2 = {username:"lee"};

const print1 = print.bind(person1);
const print2 = print.bind(person2);



print1();
print2();


const print3 = print2.bind({username:"park"})
print3();


//////////////////////////////////////////////////////////////////////////////////////////

    //함수선언문
    //함수 선언문 같은경우도 호이스팅이 일어난다.
    a();

    function a() {
      console.log("test A");
    }

//////////////////////////////////////////////////////////////////////////////////////////


    // b(); 
    // 함수표현식은 호이스팅이 일어나지 않는다.

    //함수표현식
    const b = function(){
      console.log("함수표현식")
    }
    b();


//////////////////////////////////////////////////////////////////////////////////////////
/* ※정리※ */
/*
- 함수선언식은 호이스팅이 일어난다.
- 함수표현식은 호이스팅이 일어나지 않는다.
AirBnb의 JS Style가이드에서 함수선언식보다는 함수표현식을 지향
*/


//////////////////////////////////////////////////////////////////////////////////////////
/* 애로우함수 */
//람다함수와 비슷함
//const 변수명=(입력)=>출력
//단, 애로우함수가 기존의 함수선언문이나 함수표현식을 완전히 대신할 수 없다.
// const a = (x) =>{return x;};
// const erroew = () => {console.log('Hello');};
//(짧게 표현하기)
const erroew = () => 'Hello';
console.log(erroew());
//인자가 하나일때는 괄호(()) 생략가능
//명령어가 하나일때는 중괄호({}) 생략가능

//////////////////////////////////////////////////////////////////////////////////////////
const c = (x='기본값') => x+100;
console.log(c());

const obj = {
 name: 'KOSMO',
 goodBy:function(){console.log('GoodBy! '+this.name)}      
};
 obj.goodBy();

 const obj2 = {
 username: 'KOSMO',
 goodBy:()=>console.log('GoodBy! '+this.username)//이때 this.는 window     
};
 obj2.goodBy();
//this키워드 사용시 애로우를 사용하면 아된다.

// const button = document.getElementById('button');
// button.addEventListener('click', function(){
//   console.log(this); // button
//   this.innerHTML = '클릭해주세요';
// });


//////////////////////////////////////////////////////////////////////////////////////////
/* 클래스 정의 */
//클래스선언문은 호이스팅이 되지 않는다.
class Person{
  constructor(username='기본값'){
    this.username = username;
  }
   printName() {
    console.log(this.username);
  }
}
const person = new Person('나길동');
console.log(person.username)
console.log(person.printName())

//클래스 표현식 (잘않쓴다.)
const Person2 = class{
  constructor(username){
    this.username = username;
  }
}

//클래스 메소드 : 생성자
class Student extends Person{
  constructor(username,stNumber){
    super(username);
    this.stNumber = stNumber;
  }
  printStudent(){
    console.log(this.stNumber, this.name)
    console.log('학생입니다')
  }
  
  static staticMethod(x,y){
    console.log(this.username); //인스턴스가 되어있지 않으니 undefined, 의미가 없다.
    console.log('정적메소드')
    return x+y;
  }



}

// const child1 = new Student()
// child1.printStudent();
// child1.printName();


const child1 = new Student('와우',30);
console.log(child1);

//정적메소드는 클래스명으로접근한다.
console.log(Student.staticMethod(1,10));



'use strict'
username = '가길동';
console.log(username);

//////////////////////////////////////////////////////////////////////////////////////////
/* import와 export */    
//페이지 방식
  </script>
  <!-- 페이지 방식 : 아래 스크립트 위치가 중요하다. -->
  <script src="./js/a.js"></script>
  <script src="./js/c.js"></script>
  <script src="./js/b.js"></script>
  <script>
    console.log(username);
  </script>

<!-- 위 내용을 더 깔끔하게 모듈화로 묶어서 보내버리기 -->
  <script type="module">
    import arr,{username,obj} from './js/exa.js';
    console.log(username);
    console.log(obj);
    console.log(arr)
    
    import exb_username,{add,minus} from './js/exb.js';
    console.log(exb_username);
    console.log(add(10,20));
    console.log(minus(10,20));

    import exc_username from './js/exc.js';
    console.log(exc_username);


    
    //Babel : ES6 -> ES5로 트랜스파일러 해주는 것것
    //Webpack : 번들러라고 하는데 여러 모듈을 하나로 묶는걸 말한다.
    //export는 여러번
    //export default는 한번만 사용 가능하다.
  </script>

<script type="module">
  import './js/index.js'


//////////////////////////////////////////////////////////////////////////////////////////
  /* Spread연산자 */
  //Iterable Object : 반복가능한 객체
  //반복가능한 객체를 전개하는 전개연산자라고 한다.
  console.log('--------------------------▼')
  const arr1=[1,2,3];
  const arr2=[4,5,6];
  const arr3 = [...arr1,...arr2,7,8,9]
  console.log(arr3);

  const object1={name:'가길동',age:20};
  const object2={
    name:'나길동',
    age:40,
    addr:'가산동',
    company:{
      name:'코스모',
      contacts:
      {tel:'010-123-4567', mobile:'010-999-9999'}

    }
};

const object3= {...object2, ...object1,company:{...object2.company,contacts:{...object2.company.contacts,tel:'111-1111-1111'}}};
console.log(object3);
console.log(object3.company.contacts.tel);


//////////////////////////////////////////////////////////////////////////////////////////
//...(Sprad 연산자)는 반복가능한객체를 전개한다.
console.log('--------------------------▼')
//함수호출시 배열을 전달달
var add3 = function add(a, b, c, d, e) {
  return a + b + c + d + e;
};
var arrA=[1,2,3,4,5];
// console.log(add3.apply(undefined,arrA));
console.log(add3(...arrA));


console.log('--------------------------▼')
const add6 = (a,b,c,d,e) => {return a+b+c+d+e};
const arrB = [1,2,3,4,5];
console.log(add6(...arrB));

const str = 'KOSMO';
const arr = [ ... str];
console.log(arr);//["K", "O", "S", "M", "O"]


//////////////////////////////////////////////////////////////////////////////////////////

const boards = {
  username:'kim',
  title:'제목1',
  id:100,
  comments:[
    {id:1,comment:'댓글1',postdate:'2024-01-01'},
    {id:2,comment:'댓글2',postdate:'2024-02-01'},
    {id:3,comment:'댓글3',postdate:'2024-03-01'}

]
};

console.log('--------------------------▼')
//문1)코멘트 2번글의 comment를 comment second로 수정해라라
//내 답안
// console.log(boards.comments[1].comment='comment second')
// console.log(boards)

console.log('--------------------------▼')
// //스프레드로 해보기
const myList = ({...boards.comments[1]}.comment);
const myQ = {...boards,comments:{...boards.comments}};
console.log(myQ);
console.log(myList);

console.log('--------------------------▼')
//답안
const board2 = {
  ...boards,
  comments:boards.comments.map(comment=>comment.id === 2 ? {...comment,comment:"Comment Second"} : comment)
  };
console.log(board2)

const board3 = {
  ...board2,
  title:'첫번째 제목입니다',
  comments : boards.comments.map(comment=>comment.id === 3 ? {...comment,comment:"댓글 3번째 입니다",postdate:new Date().toISOString().substring(0,10)} : comment)
}
console.log(board3)





</script>


  <button id="button">버튼</button>
</body>
</html>